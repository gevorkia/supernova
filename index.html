<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Supernova</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="stylesheets/main.css" rel="stylesheet">
        <script src="dist/bundle.js" type="application/javascript"></script>
    </head>
    <body>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/102/three.js"></script>
        <div id="root"></div>
        <h1>Simulation of star using physical principality</h1>
        <div class="footer">
            <a class="play-button">
                <!-- <img src="https://img.icons8.com/fluent-systems-regular/96/000000/play.png" /> -->
                <img src="https://img.icons8.com/color/48/000000/play-button-circled.png" />
                <!-- <img src="https://img.icons8.com/ios-filled/50/000000/play-button-circled.png" /> -->
                
            </a>
            <div class="slider">
                <input 
                    id="timelapse-slider" 
                    type="range" 
                    value="0" 
                    max="4.354" 
                    step="1"
                >
            </div>
        </div>
        <div id="heatmap-bar" title="Change units to “K”" class="pq">
            <span class="temp-units" style="">MeV</span>
            <span class="heatmap" style="background: red; color:white;">90</span>
            <span class="heatmap" style="background: orange; color: rgb(0, 0, 0);">70</span>
            <span class="heatmap" style="background: rgba(235, 211, 53, 0.92); color: rgb(0, 0, 0);">60</span>
            <span class="heatmap" style="background: green; color: white;">30</span>
            <span class="heatmap" style="background: blue; color: white;">20</span>
            
        </div>
        <script>
            // // every threejs proj has scene, camera, renderer (WebGL most flexibility)
            // let scene = new THREE.Scene

            // let camera = new THREE.PerspectiveCamera(
            //     75, 
            //     window.innerWidth/window.innerHeight, 
            //     0.1, 
            //     1000
            // );
            // camera.position.z = 5;

            // let renderer = new THREE.WebGLRenderer({antialias: true});
            // renderer.setClearColor("#e5e5e5");
            // renderer.setSize(window.innerWidth, window.innerHeight);

            // document.body.appendChild(renderer.domElement);

            // window.addEventListener('resize', () => {
            //     renderer.setSize(window.innerWidth, window.innerHeight);
            //     camera.aspect = window.innerWidth / window.innerHeight;
            //     camera.updateProjectionMatrix();
            // })
            // // const raycaster = new THREE.Raycaster();
            // // const mouse = new THREE.Vector2();

            // let geometry = new THREE.SphereGeometry(0.5, 10, 10);
            // let material = new THREE.MeshLambertMaterial({ color: 0xFFCC00 });
            // let mesh = new THREE.Mesh(geometry, material);
            
            // // // mesh.position.x = -2;
            // // // mesh.position.set(2, 2, -2) // (x, y, z)
            // // // mesh.rotation.set(45, 0, 0) // static rotation
            // // // mesh.scale.set(1, 2, 1)
            // scene.add(mesh);
            
            // // meshX = -10;
            // // for (let i = 0; i < 15; i++) {
            // //     let mesh = new THREE.Mesh(geometry, material);
            // //     mesh.position.x += (Math.random() - 0.5) * 10;
            // //     mesh.position.y += (Math.random() - 0.5) * 10;
            // //     mesh.position.z += (Math.random() - 0.5) * 10;
            // //     scene.add(mesh);
            // //     meshX += 1;
            // // }

            // // const light = new THREE.PointLight(0xFFFFFF, 1, 500);
            // // light.position.set(10,0, 25);
            // // scene.add(light);

            // function animate() {
            //     requestAnimationFrame(animate);
            //     // creates a loop that will cause renderer to draw scene everytime it's refreshed (standard ~60fps)
                
            //     // mesh.rotation.y += 0.02;
            //     renderer.render(scene, camera);
            // }

            // // function onMouseMove(e) {
            // //     e.preventDefault();

            // //     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            // //     mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // //     raycaster.setFromCamera(mouse, camera);
                
            // //     const intersects = raycaster.intersectObjects(scene.children, true);
            // //     for (let i = 0; i < intersects.length; i++) {
            // //         intersects[i].object.material.color.set(0xff0000)
            // //     }
            // //     mesh.position.x += 0.01;
            // // }

            // animate();



            // // window.addEventListener('mousemove', onMouseMove);

            // // document.body.addEventListener('click', () => {
                
            // // })

        </script>

    </body>
</html>